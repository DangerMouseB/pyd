module bones_vm.pyig.scanning;       // adapted from autowrap:pyd

/**
   Functions to wrap entities in D modules for Python consumption.

   These functions are usually not called directly, but from the mixin generated by
   bones_vm.pyig.boilerplate.pydBoilerplate.
 */


import std.meta : allSatisfy, AliasSeq, Filter, staticMap, templateNot;
import std.traits : isArray, hasMember, Parameters, fullyQualifiedName, ReturnType, isIntegral, getUDAs;
import std.conv : to, text;
import std.uni : toUpper;
import std.algorithm: startsWith;
import std.typecons: Tuple;
import std.format : format;

import autowrap.types : isModule;

import bones_vm.pyig.attributes;   // args, kwargs, __repr__ etc
import bones_vm.pyig.traits : _isOperator, _isPropertyFn, _isStaticMemberFunctionFn, _PublicFieldNamesFn,
    _isPublicFunction, _isMemberFunctionFn, _memberExprFromNameFn, _isMemberFnWithUda;
import bones_vm.pyig.config : SupressOperatorCompileErrors, __AlwaysTry__;

import bones_vm.pyig.tp_slots : set_tp_repr, set_tp_str, set_tp_richcompare;
import bones_vm.pyig.tp_as_number : set_nb_bool;
import bones_vm.pyig.template_play : fred;
import bones_vm.pyig.reflection : isUserAggregate, AllFunctions, AllAggregates;

import bones_vm.pyig.wrappers : OpCall, OpSliceAssign, Def, OpSlice, Len, OpIndex, OpIndexAssign, StaticDef, Property,
    PyName, def, ModuleName, Member, MemberFunction, Init, wrap_class;


private enum _isString(alias T) = is(typeof(T) == string);


///  Wrap global functions from multiple modules
void createFunctionAdaptorsFor(Modules...)() if(allSatisfy!(isModule, Modules)) {

    static foreach(function_; AllFunctions!Modules) {
        static if(__traits(
                compiles,
                def!(
                    function_.symbol,
                    //ModuleName!"bones_vm",
                    PyName!(function_.identifier)
                )()
        )){
            def!(
                function_.symbol,
                //ModuleName!"bones_vm",
                PyName!(function_.identifier)
            )();
        }else{
            pragma(msg, "\nERROR! Autowrap could not wrap function `", function_.identifier, "` for Python\n");
            def!(
                function_.symbol,
                //ModuleName!"bones_vm",
                PyName!(function_.identifier)
            )();
        }
    }
}


/**
   wrap all aggregates found in the given modules, specified by their name
   (to avoid importing all of them first).

   This function wraps all struct and class definitions, and also all struct and class
   types that are parameters or return types of any functions found.
 */
void createAggregateAdaptorsFor(Modules...)() if(allSatisfy!(isModule, Modules)) {
    fred();
    static foreach(aggregate; AllAggregates!Modules) {
        //pragma(msg, aggregate);
        static if(__AlwaysTry__ || __traits(compiles, wrapAggregate!aggregate))
            wrapAggregate!aggregate;
        else {
            pragma(msg, "\nERROR! Autowrap could not wrap aggregate `", fullyQualifiedName!aggregate, "` for Python\n");
            wrapAggregate!aggregate; // uncomment to see the error messages from the compiler
        }
    }
}




void wrapAggregate(T)() if(isUserAggregate!T) {
    alias memberExprFromNameUnary(string memberName) = _memberExprFromNameFn!(T, memberName);

    alias members = staticMap!(memberExprFromNameUnary, __traits(allMembers, T));
    alias memberFunctions = Filter!(_isMemberFunctionFn, members);
    alias magicMethods = Filter!(isMagicMethod, members);

    alias staticMemberFunctions = Filter!(_isStaticMemberFunctionFn, memberFunctions);
    alias nonStaticMemberFunctions = Filter!(templateNot!_isStaticMemberFunctionFn, memberFunctions);
    alias regularMemberFunctions = Filter!(templateNot!_isOperator, Filter!(templateNot!_isPropertyFn, nonStaticMemberFunctions));
    alias properties = Filter!(_isPropertyFn, nonStaticMemberFunctions);

    // FIXME - See #54
    static if(is(T == class))
        alias publicFieldNames = AliasSeq!();
    else
        alias publicFieldNames = _PublicFieldNamesFn!T;

    alias reprFns = Filter!(_isMemberFnWithUda!__repr__, memberFunctions);
    alias strFns = Filter!(_isMemberFnWithUda!__str__, memberFunctions);
    alias boolFns = Filter!(_isMemberFnWithUda!__bool__, memberFunctions);
    alias richcmpFns = Filter!(_isMemberFnWithUda!__richcmpfunc__, memberFunctions);

    static if (reprFns.length > 0) pragma(msg, "__repr__ ", reprFns);
    static if (strFns.length > 0) pragma(msg, "__str__ ", strFns);
    static if (boolFns.length > 0) pragma(msg, "__bool__ ", boolFns);
    static if (richcmpFns.length > 0) pragma(msg, "__richcmpfunc__ ", richcmpFns);

    static assert (reprFns.length <= 1, "More than one @__repr__ for "~T.stringof);
    static assert (strFns.length <= 1, "More than one @__str__ for "~T.stringof);
    static assert (boolFns.length <= 1, "More than one @__bool__ for "~T.stringof);
    static assert (richcmpFns.length <= 1, "More than one @__richcmpfunc__ for "~T.stringof);

    //enum compiledReprs = staticMap!(assertFuncCompiles, reprFns);

    //pragma(msg, "magicMethods: ", magicMethods);
    //pragma(msg, "boolMethods: ", boolMethods);
    pragma(msg, "\n~~~~~~~~~~~~~~~~~~~~~~~~ AUTO GENERATE  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

    wrap_class!(
        T,
        staticMap!(InitTuple, ConstructorParamTuples!T),
        staticMap!(Member, publicFieldNames),
        staticMap!(MemberFunction, regularMemberFunctions),  // mustn't include markedup fns
        staticMap!(StaticDef, staticMemberFunctions),

        // tp_slots
        staticMap!(set_tp_repr, reprFns),
        staticMap!(set_tp_str, strFns),
        staticMap!(set_tp_richcompare, richcmpFns),

        // tp_as_number
        staticMap!(set_nb_bool, boolFns),

        staticMap!(Property, properties),
        OpUnaries!T,
        OpBinaries!T,
        OpBinaryRights!T,
        //OpCmps!T,
        Lengths!T,
        OpIndices!T,
        DefOpSlices!T,
        OpSliceRanges!T,
        OpOpAssigns!T,
        OpIndexAssigns!T,
        OpSliceAssigns!T,
        OpCalls!T,
    );

    pragma(msg, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
}


// A tuple, with as many elements as constructors. Each element is a
// std.typecons.Tuple of the constructor parameter types.
private template ConstructorParamTuples(alias T) {
    // If we staticMap with std.traits.Parameters, we end up with a collapsed tuple
    // i.e. with one constructor that takes int and another that takes int, string,
    // we'd end up with 3 elements (int, int, string) instead of 2 ((int), (int, string))
    // so we package them up in a std.typecons.Tuple to avoid flattening
    // each being an AliasSeq of types for the constructor
    alias ParametersTuple(alias F) = Tuple!(Parameters!F);

    static if(hasMember!(T, "__ctor"))
        alias constructors = AliasSeq!(__traits(getOverloads, T, "__ctor"));
    else
        alias constructors = AliasSeq!();

    // A tuple, with as many elements as constructors. Each element is a
    // std.typecons.Tuple of the constructor parameter types.
    alias ConstructorParamTuples = staticMap!(ParametersTuple, constructors);
}


// Apply pyd's Init to the unpacked types of the parameter Tuple.
private template InitTuple(alias Tuple) {
    alias InitTuple = Init!(Tuple.Types);
}


private bool assertFuncCompiles(alias func)() {
    static assert (__traits(compiles, func), func);
    return true;
}


private template DefOpSlices(T) {
    static if(hasMember!(T, "opSlice")) {
        // See testdll for details on this
        enum hasNoParams(alias F) = Parameters!F.length == 0;
        alias iters = Filter!(hasNoParams, __traits(getOverloads, T, "opSlice"));
        alias defIters = staticMap!(DefOpSlice, iters);

        alias DefOpSlices = AliasSeq!(defIters);
    } else
        alias DefOpSlices = AliasSeq!();
}


private template DefOpSlice(alias F) {
    alias DefOpSlice = Def!(F, PyName!"__iter__", ReturnType!F function(Parameters!F));
}


private template OpSliceRanges(T) {
    static if(hasMember!(T, "opSlice")) {
        enum hasTwoIntParams(alias F) =
            allSatisfy!(isIntegral, Parameters!F) && Parameters!F.length == 2;
        alias twoInts = Filter!(hasTwoIntParams, __traits(getOverloads, T, "opSlice"));

        static if(twoInts.length > 0) {
            // pyd is very specific about this for some reason
            static if(__AlwaysTry__ || __traits(compiles, OpSlice!().Inner!T))
                alias OpSliceRanges =  OpSlice!();
            else
                alias OpSliceRanges = AliasSeq!();
        } else
            alias OpSliceRanges = AliasSeq!();
    } else
        alias OpSliceRanges = AliasSeq!();
}




private alias OpBinaries(T)     = Operators!(T, "opBinary");
private alias OpBinaryRights(T) = Operators!(T, "opBinaryRight");
private alias OpUnaries(T)      = Operators!(T, "opUnary");
private alias OpOpAssigns(T)    = Operators!(T, "opOpAssign");


private template Operators(T, string opName) {
    static if(hasMember!(T, opName)) {
        pragma(msg, "Operators - ", T, ", ", opName);
        // figure the opName of the wrapper creation function in pyd and import it
        private enum pascalName = opName[0].toUpper.text ~ opName[1..$];
        static if(pascalName == "OpOpAssign")
            private enum pydName = "OpAssign";
        else
            private enum pydName = pascalName;
        mixin(`import bones_vm.pyig.wrappers: ` ~ pydName ~ `;`);

        // figure which operations are defined by the type being wrapped
        private enum definesOp(string op) = definesPythonOp!(T, opName, op);
        private alias definedOps = Filter!(
            definesOp,
            AliasSeq!("+", "-", "*", "/", "%", "^^", "&", "|", "^", "<<", ">>", ">>>", "~", "in")  // >>> is unsigned right shift
        );

        // throw errors if required to
        static if(!SupressOperatorCompileErrors){
            private alias opFailsToCompile(string op) = failsToCompile!(T, opName, op);
            private alias failedOps = Filter!(opFailsToCompile, definedOps);
            mixin(`alias opFunc(string op) = T.`~opName~`!op;`);
            private alias throwErrors = staticMap!(opFunc, failedOps);
        }

        // build operator wrappers
        private enum probeOpSupressFailure(string op) = is(typeof(probeTemplate!(T, opName, op)));
        private alias probed = Filter!(probeOpSupressFailure, definedOps);
        mixin(`alias toPyd(string op) = ` ~ pydName ~ `!op;`);
        alias Operators = staticMap!(toPyd, probed);
        //pragma(msg, "failedOps: ", failedOps);

    } else
        alias Operators = AliasSeq!();
}


private bool definesPythonOp(T, string opName, string op)() {
    static if(hasMember!(T, opName)) {
        alias overloads = AliasSeq!(__traits(getOverloads, T, opName, true));
        enum hasAttr(alias fn) = opFuncHasMagicAttr!(T, opName, fn, op);
        alias overloadsWithAttr = Filter!(hasAttr, overloads);
        int count = overloadsWithAttr.length;
        return count > 0;
    }else{
        return false;
    }
}

private bool opFuncHasMagicAttr(T, string opName, alias opFunc, string op)() {
    static if ( false
        || (op == "+" && (hasUDA!(opFunc, __add__) || hasUDA!(opFunc, __radd__) || hasUDA!(opFunc, __pos__)))
        || (op == "-" && (hasUDA!(opFunc, __sub__) || hasUDA!(opFunc, __rsub__) || hasUDA!(opFunc, __neg__)))
        || (op == "*" && (hasUDA!(opFunc, __mul__) || hasUDA!(opFunc, __rmul__)))
        || (op == "^^" && (hasUDA!(opFunc, __pow__) || hasUDA!(opFunc, __rpow__)))
        || (op == "~" && (hasUDA!(opFunc, __invert__)))
        || (op == "in" && (hasUDA!(opFunc, __contains__)))
    ) {
        //pragma(msg, "checking definition of ", T, opName, op, " - ", true);
        return true;
    }else{
        //pragma(msg, "checking definition of ", T, opName, op, " - ", false);
        return false;
    }
}

private bool hasUDA(alias func, alias uda)() {return getUDAs!(func, uda).length != 0;}


private void probeTemplate(T, string opName, string op)() {
    enum ppName = T.stringof~"."~opName.stringof[1..$-1]~"!\""~op~"\"";
    mixin(`alias func = T.` ~ opName ~ `;`);

    alias R = ReturnType!(func!op);
    alias P = Parameters!(func!op);

    auto obj = T.init;

    // given we can't catch the fact an error has occured instead print out a list of results
    static if (__traits(compiles, func!op))
        pragma(msg, "--- aw.Operators --- ", ppName, " => ", P.stringof, " -> ", R.stringof);
    else
        pragma(msg, "--- aw.Operators --- ", ppName, " => DEFINED BUT DOES NOT COMPILE");

    static if (is(R == void))
        mixin(`obj.` ~ opName ~ `!op(P.init);`);
    else
        mixin(`R ret = obj.` ~ opName ~ `!op(P.init);`);
}

private bool failsToCompile(T, string name, string arg)() {
    mixin(`alias func = T.` ~ name ~ `;`);
    return !__traits(compiles, func!arg);
}



//private template OpCmps(T) {
//    static if(hasMember!(T, "opCmp")){
//        static if (__AlwaysTry__ || __traits(compiles, OpCompare!().Inner!T)){
//            alias OpCmps = AliasSeq!(OpCompare!());
//            pragma(msg, "--- aw.OpCmps ---  ", T.stringof);
//        }else{
//            alias OpCmps = AliasSeq!();
//            pragma(msg, "--- aw.OpCmps ---  ", T.stringof, "FAILED");
//        }
//    }else{
//        alias OpCmps = AliasSeq!();
//    }
//}


private template Lengths(T) {
    static if(is(typeof(T.init.length)))
        alias Lengths = Len!(T.length);
    else
        alias Lengths = AliasSeq!();
}


private template OpIndices(T) {
    static if(is(typeof(T.init.opIndex(0))))
        alias OpIndices = OpIndex!();
    else
        alias OpIndices = AliasSeq!();
}


private template OpIndexAssigns(T) {
    static if(hasMember!(T, "opIndexAssign")) {
        static if(__AlwaysTry__ || __traits(compiles, OpIndexAssign!().Inner!T))
            alias OpIndexAssigns = OpIndexAssign!();
        else
            alias OpIndexAssigns = AliasSeq!();
    } else
        alias OpIndexAssigns = AliasSeq!();
}


private template OpSliceAssigns(T) {
    static if(hasMember!(T, "opSliceAssign")) {
        static if(__AlwaysTry__ || __traits(compiles, OpSliceAssign!().Inner!T))
            alias OpSliceAssigns = OpSliceAssign!();
        else
            alias OpSliceAssigns = AliasSeq!();
    } else
        alias OpSliceAssigns = AliasSeq!();
}


private template OpCalls(T) {
    static if(hasMember!(T, "opCall")) {
        pragma(msg, "--- aw.OpCalls ---  ", T.stringof);
        alias overloads = AliasSeq!(__traits(getOverloads, T, "opCall"));
        alias opCall(alias F) = OpCall!(Parameters!F);
        alias OpCalls = staticMap!(opCall, overloads);
    } else
        alias OpCalls = AliasSeq!();
}





// must be a global template
private template isMagicMethod(A...) if(A.length == 1) {
    alias T = A[0];

    static if(__AlwaysTry__ || __traits(compiles, __traits(identifier, T))){
        enum name = __traits(identifier, T);
        enum isMagicMethod = _isPublicFunction!T && name.startsWith("__");
    }else{
        enum isMagicMethod = false;
    }
}

